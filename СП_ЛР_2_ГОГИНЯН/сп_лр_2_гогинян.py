# -*- coding: utf-8 -*-
"""СП_ЛР_2_Гогинян.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KQEWaDUgYND2Auseo1O292VALdFLI2Ms
"""

import numpy as np

A = np.array([[-3, 1, 0, 1, 1], [1, -3, 1, 1, 0], [0, 1, -3, 1, 1], [1, 0, 1, -3, 1], [0, 1, 1, 0, -2]])

#A = np.array([[-3, 1, 1, 1, 0], [0, -2, 0, 1, 1], [1, 0, -3, 1, 1], [1, 1, 0, -3, 1], [1, 1, 1, 0, -2]]) # Ч Н
# интенсивность выхода из состояния i
def OutputIntensity(l, i): # l- lambda_ij - строка матрицы A, i - string number
  sum = 0
  for k in range(len(l)):
    if k != i:
      sum += l[k]
  return  sum

def GetItFrequency(sequenceOfStates, numberOfReturns, returnFrequency, pastFrequecy):
  #print("сработала функция GetItFreq")
  for i in range(5):
    numberOfReturns[i] = sequenceOfStates.count(i)
    #print("количество входов в состояние "+str(i)+":", numberOfReturns[i])
    pastFrequency[i] = returnFrequency[i]
    returnFrequency[i] = numberOfReturns[i] / len(sequenceOfStates)
    #print("частота вхождений в состояние(returnFreq)"+str(i)+":", returnFrequency[i])
    

def PrCheck(freq, pastfreq): # проверка условия
  #print("PrCheck work...")
  a=[]
  for i in range(5):
     a.append(np.abs(freq[i] - pastfreq[i])) # разница последней и предпоследней частоты
  # print("массив разниц частот:",a)
  # print("Значение отклонения delta_l =", round(np.max(a), 8))
  return np.max(a) # максимум среди них

def Delta(T, tK, t1):
  return T/(tK - t1)



time = [0] # время
state = [0, 1, 2, 3, 4] # - состояния системы
i = state[0]      # начальное состояние
j = 0
numberOfReturns = [0, 0, 0, 0, 0] # R(l) -число попаданий системы в состояние i=1...5
returnFrequency = [0, 0, 0, 0, 0] # v(l) -частота попаданий
pastFrequency = [0, 0, 0, 0, 0]
T = [0, 0, 0, 0, 0] # - общее время нахождения в i-том состоянии
sequenceOfStates = []
# time.append(np.random.exponential(scale = 1/OutputIntensity(A[0], 0))) # scale = 1/lambda[1]

# переменные для вывода
l = 0 # номер события
tl = 0 # момент наступления события l
# tau_l = time[i] - время пребывания в l-ом состоянии
# delta = round(np.max(a), 6) - отклонение


#print("Определение первого состояния...")

lam = OutputIntensity(A[i], i) # лямбда - интенсивность
time.append(np.random.exponential(scale = 1/OutputIntensity(A[i], i))) # время нахождения в новом i-том состоянии

#print("lambda_i =", lam)
if lam == 0:
  j = i  # j - следующее состояние
elif lam > 0:
  num=0
  cutState = []  # список соответствующих состояний
  cutLength = [] # список длин отрезков
    
  for k in range(len(A[i])):
    if A[i][k] > 0:
      num += 1   # подсчет количества отрезков
      cutLength.append(A[i][k]/lam)
      cutState.append(k)     # длина i-го отрезка
  nextState = np.random.random_sample() # выбираем рандомное число из отрезка [0, 1], по которому определяем следующее состояние
  #print("рандомное число ", nextState)
  #print("список длин отрезков", cutLength)
  #print("список соответствующих состояний", cutState)
  cutStart = 0
  cutEnd = cutLength[0]
  buf = 0
  cut = False
  while cut == False:
    #print("проверка отрезка")
    #print("[", round(cutStart, 5), ",", round(cutEnd, 5), "]")
    if cutStart <= nextState and nextState < cutEnd:
      #print("для начала подходит")
      cut = True
      st = cutEnd - cutStart
      j = cutState[buf]
      sequenceOfStates.append(j)
      l+=1
      tl += time[len(time)-1]
      T[i] += time[len(time)-1]
      #print("j=", j, end="\n")
      GetItFrequency(sequenceOfStates, numberOfReturns, returnFrequency, pastFrequency)
    else:
      #print("для начала не подходит, следующий отрезок")
      buf+=1
      cutEnd = cutEnd + cutLength[buf]
      cutStart += cutLength[buf-1]
  tsob1 = tl
  time.append(np.random.exponential(scale = 1/OutputIntensity(A[j], j)))
  print(l, "\t", tl, "\t", j+1, "\t", time[len(time)-1], "\t", round(PrCheck(returnFrequency, pastFrequency) ,7))


while PrCheck(returnFrequency, pastFrequency) >= 0.0001:
  if l == 100:
    print(100, "\tRi(100) \tvi(100)	\tTi(100)	\tDelta_i(100) --------")
    for i in range(5):
      print(i+1, "\t", numberOfReturns[i], "\t", returnFrequency[i], "\t", T[i], "\t", Delta(T[i], tl, tsob1), end="\n")
    print("----------------------------------------------")
  i = j                # предыдущее состояние
  lam = OutputIntensity(A[i], i)
  #time.append(np.random.exponential(scale = 1/OutputIntensity(A[i], i))) # время нахождения в новом i-том состоянии
  #print("Определение следующего состояния...")
  #print("lambda_i =", lam)
  if lam == 0:
    j = i          # j - следующее состояние
  elif lam > 0:
    num=0
    cutState = []  # список соответствующих состояний
    cutLength = [] # список длин отрезков
    for k in range(len(A[i])):
      if A[i][k] > 0:
        num += 1   # подсчет количества отрезков
        cutLength.append(A[i][k]/lam)
        cutState.append(k)     # длина i-го отрезка
    nextState = np.random.random_sample() # выбираем рандомное число из отрезка [0, 1], по которому определяем следующее состояние
    # print("рандомное число ", nextState)
    #print("список длин отрезков", cutLength)
    #print("список соответствующих состояний", cutState)
    cutStart = 0
    cutEnd = cutLength[0]
    cut = False
    buf = 0
    while cut == False:
      # print("проверка отрезка [", round(cutStart, 5), ",", round(cutEnd, 5), "]")    
      if cutStart <= nextState and nextState < cutEnd:
        #print("подходит")
        cut = True
        st = cutEnd - cutStart
        j = cutState[buf]  # определили новое состояние
        sequenceOfStates.append(j)
        l+=1
        tl += time[len(time)-1] 
        T[i] += time[len(time)-1] # общее время пребывания в событии j
        #print("j=", j, end="\n")
        GetItFrequency(sequenceOfStates, numberOfReturns, returnFrequency, pastFrequency)
      else:
        #print("не подходит, следующий отрезок")
        buf+=1
        cutEnd = cutEnd + cutLength[buf]
        cutStart += cutLength[buf-1]
    time.append(np.random.exponential(scale = 1/OutputIntensity(A[j], j)))
    print(l, "\t", tl, "\t", j+1, "\t", time[len(time)-1], "\t", round(PrCheck(returnFrequency, pastFrequency) ,7))


print()
for i in range(5):
  print(i+1, "\t", numberOfReturns[i], "\t", returnFrequency[i], "\t", T[i], "\t", Delta(T[i], tl, tsob1), end="\n")