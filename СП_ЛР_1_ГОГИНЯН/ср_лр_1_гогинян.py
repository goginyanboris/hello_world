# -*- coding: utf-8 -*-
"""СР_ЛР_1_Гогинян

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Xuu4V7MPJ4QCvIwG70gyXoaz8-CdGtBX

1 матрица переходных вероятностей  \\
"""

import numpy as np

M = np.array([[0.437, 0.563, 0],
              [0.409, 0.591, 0],
              [0.235, 0.22, 0.545]])

arrayM = [M] # Array list P^n

def PrCheck (lastP, P, module = False):
  # PrCheck returns delta_n
  if module == False:
    return np.max(np.abs(np.array(P) - np.array(lastP)))
  else:
    # print("vec[i] =", P)
    return np.abs(P - lastP)
  
  
  
  
# 1 exercise
lastM = M
currentM = np.dot(M, M)
num = 0

print("Матрицы для 1 номера ------------------")
while PrCheck(lastM, currentM) >= 0.000001:
  arrayM.append(lastM)
  # print(np.round(lastM, 5), "\t", PrCheck(lastM, currentM))
  num += 1
  lastM = currentM
  currentM = np.dot(lastM, M)# P^n
  
print("---- 1 задание -----------------------------------------------------------------")
  
# 2 exercise - сделать на бумажке
  
# решаем систему _p = _p * P1, где _p - стационарное распределение
# 0.437*p1 + 0.563*p2 + 0*p3 = p1
# 0.409*p1 + 0.591*p2 + 0*p3 = p2
# 0.235*p1 + 0.22*p2 + 0.545*p3 = p3
# p1 + p2 + p3 = 1

# преобразуем и тк ранг системы 2, одно можно выкинуть

# -0.563*p1 + 0.563*p2 + 0*p3 = 0
# 0.409*p1 - 0.409*p2 + 0*p3 = 0
# 0.235*p1 + 0.22*p2 - 0.455p*3 = 0
# p1 + p2 + p3 - 1 = 0

vec = np.array([409/972, 563/972, 0])

#print("vec =", vec)
#print("vec * M =", np.dot(vec, M))
#print()

print("3 exercise ----------------------------")
initialState = np.identity(3, dtype=float) 
print(initialState)

arrayInitialState = []
lastInitialState = initialState

for i in range(3):
  print("\nNew vector")
  while PrCheck(lastInitialState[i], vec) >= 0.00001 :
    arrayInitialState.append(lastInitialState)
    print(lastInitialState[i], "\t", PrCheck(lastInitialState[i], vec), "\n")
    
    lastInitialState[i] = np.dot(lastInitialState[i], M)
  print(lastInitialState[i], "\t", PrCheck(lastInitialState[i], vec), "\n")
#print(lastInitialState)

# exercise 4

for i in range(1,4) :
  print("--------------------------------------------\ni = ", i)
  sequenceOfStates = [i]
  numberOfReturns = 0
  returnFrequency  = 0
  n = 1
  while PrCheck(returnFrequency, vec[i-1], module = True) >= 0.001 :
    memberOfTheSequence = np.random.random_sample()
    
    # вывод для таблицы
    print(n, "\t", round(numberOfReturns, 5), "\t", round(returnFrequency, 5), "\t", round(PrCheck(returnFrequency, vec[i-1], module = True), 5))
    n+=1
    
    lastState = sequenceOfStates[len(sequenceOfStates) - 1]

    if memberOfTheSequence < M[lastState-1][0] :
      sequenceOfStates.append(1)

    elif memberOfTheSequence < M[lastState-1][0] + M[lastState-1][1] :
      sequenceOfStates.append(2)
    else :
      sequenceOfStates.append(3)
    numberOfReturns = sequenceOfStates.count(i) # возвращает количество чисел i, встречающихся в последовательности 
    returnFrequency = numberOfReturns / len(sequenceOfStates)
    

    
  print("Длина массива для нач. сост. (N_min(i))" +str(i)+ " = ", len(sequenceOfStates)) # выводим длину массива N

